
# 1


```
	.globl __start
  .text 0x00400000
__start:
  li $t0,25
  li $t1,30
  add $s0,$t1,$t0
  add $s0,$s0,$s0

```

## Nº de instrucciones

Se traduce en 4 instrucciones

## Instrucciones

```
[00400000] 34080019  ori $8, $0, 25           ; 4: li $t0,25
[00400004] 3409001e  ori $9, $0, 30           ; 5: li $t1,30
[00400008] 01288020  add $16, $9, $8          ; 6: add $s0,$t1,$t0
[0040000c] 02108020  add $16, $16, $16        ; 7: add $s0,$s0,$s0
```

## Dirección intrucción

```
0040000c
```

## Instrucción codificada
```
[00400008] 01288020  add $16, $9, $8          ; 6: add $s0,$t1,$t0
```

## Resultado

```
6e
```

## Instrucciones con inmediatos más grandes


```
[00400000] 3c010001  lui $1, 1                ; 4: li $t0,75369
[00400004] 34282669  ori $8, $1, 9833         
[00400008] 340932b0  ori $9, $0, 12976        ; 5: li $t1,12976
[0040000c] 01288020  add $16, $9, $8          ; 6: add $s0,$t1,$t0
[00400010] 02108020  add $16, $16, $16        ; 7: add $s0,$s0,$s0
```

# 2

```
  .globl __start
  .data 0x10000000
A: .word 25
B: .word 30
P: .space 4
  .text 0x00400000
__start:
  la $t0,A
  la $t1,B
  la $t2,P
  lw $s0,0($t0)
  lw $s1,0($t1)
  add $s2,$s1,$s0
  add $s2,$s2,$s2
  sw $s2,0($t2)

```

## Bytes ocupados por la memoria principal

Dos words y .space 4 son 4 espacios en blanco = 12 bytes

## Instrucciones de acceso a la memoria principal

lw y sw lo son, así que 3.

## Dirección del perímetro

La dirección en el primer byte de $t2, que es donde está guardada la dirección de P, que es el noveno byte, ergo 0x1000000c

## ¿Por qué la pseudoinstrucción la $t0,A se traduce en sólo una instrucción máquina y la $t1,B lo hace en dos?

Porque como los inmediatos inferiores de la dirección de A son todo ceros, el ori no es necesario, pero en B los inmediatos inferiores son 0x0004, así que si hace falta el ori.

# ¿Por qué .space 4?

Space 4 deja 4 bytes de espacio.

## .space 4 vs .word 0

Dan el mismo resultado, pero semánticamente para el programador significa algo diferente.

## ¿Qué valor contiene el registro $t1 cuando se ejecuta la instrucción `lw $s1,0($t1)`?

La dirección del primer byte de la palabra B, es decir, 0x10000004

# 3

## Llamadas al sistema

```
  # Imprimir por pantalla
  li $v0, 1 # código de print_int
  move $a0, $s2 # argumento de print_int 
  syscall # llamar a print_int
```